// Code generated by https://github.com/GoComply/metaschema; DO NOT EDIT.
// Multiplexers are indirect models needed for serialization/deserialization
// as json and xml files differ materially in their structure.
{{$packageName := .GoPackageName -}}
{{$m := . -}}
package {{ $packageName }}

import (
        "bytes"
        "encoding/json"
)

{{range .Multiplexers}}
  type {{.GoTypeName}} []{{.GoTypeNameOriginal}}

  func (mplex *{{.GoTypeName}}) UnmarshalJSON(b []byte) error {
          {{- if .InJsonMap}}
          var insideMap map[string]{{.GoTypeNameOriginal}}
	        if err := json.Unmarshal(b, &insideMap); err != nil {
                  return err
          }

          l := make([]{{.GoTypeNameOriginal}}, 0, len(insideMap))
          for k, v := range insideMap {
                  v.{{.JsonKey}} = k
                  l = append(l, v)
	        }
          {{- else}}
                  var l []{{.GoTypeNameOriginal}}
                  switch b[0] {
                  case '{':
                          var singleton {{.GoTypeNameOriginal}}
                          if err := json.Unmarshal(b, &singleton); err != nil {
                                  return err
                          }
                          l = append(l, singleton)
                  default:
                          if err := json.Unmarshal(b, &l); err != nil {
                                  return err
                          }
                 }
          {{- end}}
          (*mplex) = l
          return nil
  }

  func (mplex *{{.GoTypeName}}) MarshalJSON() ([]byte, error) {
      {{- if .InJsonMap}}
          js := bytes.NewBuffer([]byte{'{'})

          empty := true
          for _, v := range *mplex {
                  if !empty {
                          if err := js.WriteByte(','); err != nil {
                                  return []byte{}, err
                          }
                  }
                  empty = false

                  if _, err := js.WriteString("\"" + v.{{.JsonKey}} + "\":"); err != nil {
                          return []byte{}, err
                  }

                  text, err := json.Marshal(&v)
                  if err != nil {
                          return []byte{}, err
                  }
                  if _, err = js.Write(text); err != nil {
                          return []byte{}, err
                  }
          }
          if err := js.WriteByte('}'); err != nil {
                  return []byte{}, err
          }
          return js.Bytes(), nil
      {{- else}}
          js := bytes.NewBuffer([]byte{'['})

          empty := true
          for _, v := range *mplex {
                  if !empty {
                          if err := js.WriteByte(','); err != nil {
                                  return []byte{}, err
                          }
                  }
                  empty = false

                  text, err := json.Marshal(&v)
                  if err != nil {
                          return []byte{}, err
                  }
                  if _, err = js.Write(text); err != nil {
                          return []byte{}, err
                  }
          }
          if err := js.WriteByte(']'); err != nil {
                  return []byte{}, err
          }
          return js.Bytes(), nil
      {{- end}}
  }

{{- end}}
